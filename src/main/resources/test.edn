(def fn-0 (fn [] (println "No args call!")))
(if true (println "Hello\nWorld!"))
(if nil
  (println "you don't see me")
  (println (prn-str (quote (println "I'm quoted!")))))
(let [blarg println
      println quote
      fn-1 (fn [arg]
               (blarg "Passed argument: " (prn-str arg))
               arg)]
     (blarg (println (let works !)))
     (fn-0)
     (fn-1 "Just passing by."))
; a comment
((fn [do if quote let fn]
     (println do if quote let fn))
  1 2 3 4 5)
(def multi
  (fn ([] (println "Nothing to see."))
      ([x] (println "Something to see: " x))))
(multi)
(multi "FooBar!")
(println (#{:test} :test))
(println ({:key :value} :key))

(do (def a 1)
    (def b 2))

[:list (list a b)]
[:vector (vector a b)]
[:vector-literal [a b]]
[:set (hash-set a b)]
[:set-literal #{a b}]
[:map (hash-map :a a :b b)]
[:map-literal {:a a :b b}]

;; testing varargs functions

; one-arg
(def v (fn [& args] args))
(v)
(v 1)
(v 1 2)
(v 1 2 3)
(v 1 2 3 4)
(v 1 2 3 4 5)

; two-arg
(def v (fn [a & args] [a args]))
(v)
(v 1)
(v 1 2)
(v 1 2 3)
(v 1 2 3 4)
(v 1 2 3 4 5)

; three-arg
(def v (fn [a b & args] [a b args]))
(v)
(v 1)
(v 1 2)
(v 1 2 3)
(v 1 2 3 4)
(v 1 2 3 4 5)

(seq #{1 2})
(seq {:a 1 :b 2})
(seq nil)

(first (quote (1 2 3)))
(first [1 2 3])
(first #{1 2 3})
(first {:a 1 :b 2 :c 3})
(first nil)
(first [])

(next (quote (1 2 3)))
(next [1 2 3])
(next #{1 2 3})
(next {:a 1 :b 2 :c 3})
(next nil)
(next [])

(rest (quote (1 2 3)))
(rest [1 2 3])
(rest #{1 2 3})
(rest {:a 1 :b 2 :c 3})
(rest nil)
(rest [])
