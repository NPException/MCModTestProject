(ns nplisp.core

  ;; implemented as a special case in de.npcomplete.nplisp.Lisp#lookup
  (def eval)

  (defmacro declare
    [name]
    (list 'def name))

  (defmacro defn
    [name & fn-declaration]
    (list 'def name
      (apply list 'fn name fn-declaration)))


  ;; LOGIC FUNCTIONS AND MACROS

  (defn not [x]
    (if x false true))


  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     (list 'if x
       (cons 'and next)
       x)))


  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     (list 'if x
       x
       (cons 'or next))))


  ;; COMPARISONS

  (defn =
    ([x] true)
    ([x y] (equals x y))
    ([x y & more]
     (if (equals x y)
       (if (next more)
         (recur y (first more) (next more))
         (equals y (first more)))
       false)))


  ;; CONDITIONALS

  (defmacro if-not
    ([test then]
     (list 'if test nil then))
    ([test then else]
     (list 'if test else then)))


  (defmacro when
    [test & body]
    (list 'if test (cons 'do body)))


  (defmacro when-not
    [test & body]
    (list 'if test nil (cons 'do body)))


  (defmacro cond
    [& clauses]
    (if clauses
      (list 'if (first clauses)
        (first (next clauses))
        (cons 'cond (next (next clauses))))))


  ;; DATA STRUCTURE MANIPULATION

  (defn concat
    ([] '())
    ([x] x)
    ([x y]
     (let [s (seq x)]
       (if s
         (cons (first s) (concat (rest s) y))
         (seq y))))))
