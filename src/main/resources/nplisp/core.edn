(ns nplisp.core
  ;; TODO: def all core functions (and add docstrings)

  ;; redefine 'def' with itself to add a docstring
  (def def
    "Creates and interns or locates a global var with the
    name of symbol and a namespace of the value of the current namespace (*ns*)."
    def)

  ;; implemented as a special cases in de.npcomplete.nplisp.Lisp#lookup
  (def eval)
  (def *ns*)


  (def concat
    (fn concat
      ([] '())
      ([x] x)
      ([x y]
       (concat* x y))
      ([x y & zs]
       (apply concat (concat* x y) zs))))


  (def sequence
    (fn [coll]
      (if (seq? coll)
        coll
        (let [s (seq coll)]
          (if s s ())))))


  ;; everything available for syntax quote now
  (def syntax-quote)


  (def decode-defn-args
    (fn [args]
      (let [arg (first args)
            flags (if (vector? arg) arg)
            args (if flags (next args) args)
            name (first args)
            args (next args)
            arg (first args)
            docstring (if (string? arg) arg)
            specs (if docstring (next args) args)]
        {:flags flags
         :name  name
         :doc   docstring
         :specs specs})))


  (def [:macro] defn
    "Same as (def name (fn [params*] exprs*))
    or (def name (fn ([params* ] exprs*)+))
    with any doc-string or tags."
    (fn [& args]
      (let [fn-map (decode-defn-args args)
            flags (apply vector (:flags fn-map))
            name (:name fn-map)
            doc (:doc fn-map)
            doc (if doc doc "")
            specs (:specs fn-map)]
        `(def ~flags ~name ~doc
           (fn ~name ~@specs)))))


  (defn [:macro] defmacro
    ;; identical to defn, but sets the :macro flag on the defined var
    [& args]
    (let [fn-map (decode-defn-args args)
          flags (apply vector :macro (:flags fn-map))
          name (:name fn-map)
          doc (:doc fn-map)
          doc (if doc doc "")
          specs (:specs fn-map)]
      `(defn ~flags ~name ~doc ~@specs)))


  (defmacro declare
    [name]
    `(def ~name))


  (defn identity [x] x)


  ;; LOGIC FUNCTIONS AND MACROS

  (defn not [x]
    (if x false true))


  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     ;; TODO: implement gensym
     `(let [__gensym-and ~x]
        (if __gensym-and
          (and ~@next)
          __gensym-and))))


  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     ;; TODO: implement gensym
     `(let [__gensym-or ~x]
        (if __gensym-or
          __gensym-or
          (or ~@next)))))


  ;; COMPARISONS

  (defn =
    ([x] true)
    ([x y] (equals x y))
    ([x y & more]
     (if (equals x y)
       (if (next more)
         (recur y (first more) (next more))
         (equals y (first more)))
       false)))


  ;; CONDITIONALS

  (defmacro if-not
    ([test then]
     `(if ~test nil ~then))
    ([test then else]
     `(if ~test ~else ~then)))


  (defmacro when
    [test & body]
    `(if ~test (do ~@body)))


  (defmacro when-not
    [test & body]
    `(if ~test nil (do ~@body)))


  (defmacro cond
    [& clauses]
    (if clauses
      `(if ~(first clauses)
         ~(first (next clauses))
         (cond ~@(next (next clauses))))))


  ;; MACRO EXPANSION

  (defmacro macroexpand-1
    "If form represents a macro form, returns its expansion
    in the context of the current namespace,
    else returns form."
    [x]
    `(macroexpand-1* *ns* ~x))


  (defmacro macroexpand
    "Repeatedly calls macroexpand-1 on form until it no longer
    represents a macro form, then returns it.  Note neither
    macroexpand-1 nor macroexpand expand macros in subforms."
    [x]
    `(macroexpand* *ns* ~x))


  (defmacro macroexpand-all
    "Recursively performs all possible macroexpansions in form
    in the context of the current namespace."
    [x]
    `(macroexpand-all* *ns* ~x))

  )